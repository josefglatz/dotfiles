# Loads `.env` file from a filename passed as an argument
loadenv() {
  while read line; do
    if [ "${line:0:1}" = '#' ]; then
      continue  # comments are ignored
    fi
    export $line > /dev/null
  done < "$1"
  echo 'Loaded!'
}

# broot (brew) https://dystroy.org/broot/install-br/
# --------------------------------------------------
# Shell Function for broot -> br got via `broot --print-shell-function zsh`

# This script was automatically generated by the broot program
# More information can be found in https://github.com/Canop/broot
# This function starts broot and executes the command
# it produces, if any.
# It's needed because some shell commands, like `cd`,
# have no useful effect if executed in a subshell.
function br {
    f=$(mktemp)
    (
	set +e
	broot --outcmd "$f" "$@"
	code=$?
	if [ "$code" != 0 ]; then
	    rm -f "$f"
	    exit "$code"
	fi
    )
    code=$?
    if [ "$code" != 0 ]; then
	return "$code"
    fi
    d=$(<"$f")
    rm -f "$f"
    eval "$d"
}

# Homebrew Upgrade for greedy formulars/casks
# -------------------------------------------------
# just pass an existing homebrew formulae/cask name
function brew-upgrade-greedy {
  echo "${YELLOW}Upgrading greedy cask \"$1\" ${RED} without any warranty!${RESET}"
  brew upgrade --greedy $1
}

# trash with information
# ----------------------
# wrapper for trash
function move-to-trash {
  if test $(brew --prefix)/bin/trash; then
    echo "${YELLOW}Moving following items to ðŸ—‘ ${RESET} (trash):"
    $(brew --prefix)/bin/trash -v "$@" | column
    echo "\n(List all trash items with command ${YELLOW}trash -l${RESET})\n"
  fi
}

if test $(which fzf); then
  # fh - repeat history (with fzf)
  # ------------------------------
  # a fuzzy finder powered history

    fh() {
      print -z $( ([ -n "$ZSH_NAME" ] && fc -l 1 || history) | fzf +s --tac | sed -E 's/ *[0-9]*\*? *//' | sed -E 's/\\/\\\\/g')
    }


  # find-in-file - usage: fif <SEARCH_TERM>
  # ---------------------------------------
  fif() {
    if [ ! "$#" -gt 0 ]; then
      echo "Need a string to search for!";
      return 1;
    fi
    rg --hidden --files-with-matches --no-messages "$1" | fzf $FZF_PREVIEW_WINDOW --preview "rg --ignore-case --pretty --context 10 '$1' {}"
  }
  alias find-in-file="fif"

  # fda - including hidden directories
  # ---------------------------------------------
  # https://github.com/junegunn/fzf/wiki/examples
  fda() {
    local dir
    dir=$(find ${1:-.} -type d 2> /dev/null | fzf +m) && cd "$dir"
  }
  alias find-directory-all="fda"
  
fi

# lazygit "alias" with auto cd after quiting application support
# --------------------------------------------------------------
# https://github.com/jesseduffield/lazygit/#changing-directory-on-exit
lg()
{
    export LAZYGIT_NEW_DIR_FILE=~/.lazygit/newdir

    lazygit "$@"

    if [ -f $LAZYGIT_NEW_DIR_FILE ]; then
            cd "$(cat $LAZYGIT_NEW_DIR_FILE)"
            rm -f $LAZYGIT_NEW_DIR_FILE > /dev/null
    fi
}

# "g" alias for GIT with fallback to git status
# --------------------------------------------------------
# No arguments: `git status`
# With arguments: acts like `git`
# https://github.com/thoughtbot/dotfiles
unalias g
g() {
  if [[ $# -gt 0 ]]; then
    git "$@"
  else
    git status -sb
  fi
}

# Find installed app by app name oder bundleId
# -----------------------------------------------------------------------------------
# Example: whichapp finder            # -> '/System/Library/CoreServices/Finder.app/'
# Example: whichapp com.apple.finder  # -> '/System/Library/CoreServices/Finder.app/'
# https://stackoverflow.com/a/12900116
whichapp() {
  local appNameOrBundleId=$1 isAppName=0 bundleId
  # Determine whether an app *name* or *bundle ID* was specified.
  [[ $appNameOrBundleId =~ \.[aA][pP][pP]$ || $appNameOrBundleId =~ ^[^.]+$ ]] && isAppName=1
  if (( isAppName )); then # an application NAME was specified
    # Translate to a bundle ID first.
    bundleId=$(osascript -e "id of application \"$appNameOrBundleId\"" 2>/dev/null) ||
      { echo "$FUNCNAME: ERROR: Application with specified name not found: $appNameOrBundleId" 1>&2; return 1; }
  else # a BUNDLE ID was specified
    bundleId=$appNameOrBundleId
  fi
    # Let AppleScript determine the full bundle path.
  fullPath=$(osascript -e "tell application \"Finder\" to POSIX path of (get application file id \"$bundleId\" as alias)" 2>/dev/null ||
    { echo "$FUNCNAME: ERROR: Application with specified bundle ID not found: $bundleId" 1>&2; return 1; })
  printf '%s\n' "$fullPath"
  # Warn about /Volumes/... paths, because applications launched from mounted
  # devices aren't persistently installed.
  if [[ $fullPath == /Volumes/* ]]; then
    echo "NOTE: Application is not persistently installed, due to being located on a mounted volume." >&2 
  fi
}

# Find bundleId of given app
# -----------------------------------------------------------
# Example: bundleid finder            # -> 'com.apple.finder'
# https://stackoverflow.com/a/12900116
bundleid() {
  osascript -e "id of application \"$1\"" 2>/dev/null || 
    { echo "$FUNCNAME: ERROR: Application with specified name not found: $1" 1>&2; return 1; }
}

# Use Ctrl-x,Ctrl-l to get the output of the last command
# -------------------------------------------------------
# Based on https://github.com/skwp/dotfiles/commit/2ad786a41b29277530ebb4c50bcb65f3971d4901
zmodload -i zsh/parameter
insert-last-command-output() {
LBUFFER+="$(eval $history[$((HISTCMD-1))])"
}
zle -N insert-last-command-output
bindkey "^X^L" insert-last-command-output

# Load other functions
# ---------------------------------------------
# E.g for overriding existing functions locally
# which is not part of dotfiles repository

# Source ~/.dotfiles_local/.functions_local (if file exists)
if [[ -f "$DOTFILES_DIRECTORY_LOCAL/.functions_local" ]]; then
  source "$HOME/.functions_local"
fi
# Source files in ~/.dotfiles_local/functions (if folder exists)
if [[ -d "$DOTFILES_DIRECTORY_LOCAL/functions" ]]; then
  for file in "$(find $DOTFILES_DIRECTORY_LOCAL/functions -maxdepth 1 -name '*.zsh' -print -quit)"; do source $file; done
fi
# Source ~/.functions_local (if file exists)
if [[ -f "$HOME/.functions_local" ]]; then
  source "$HOME/.functions_local"
fi